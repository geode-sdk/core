# lilac::core::meta

Welcome to C++ metaprogramming hell!

### Abstract

Calling conventions suck. Especially undocumented ones, that are only generated for tightly optimized code.
Unfortunately, this is a reality we must deal with when attempting to interface with binaries with functions
that were only meant to be called internally. Luckily, C++ offers some very basic metaprogramming that we
can abuse in order to invoke these functions without having to manually write inline assembly every function call.

### Design

Meta is mostly split into two user interfaces: Function and Hook. While these are not fully fleshed out yet, their
wrapper abilities are complete. They are a generic interface to functions with non-conventional calling conventions,
which can be customized by subclassing the CallConv class and manipulating parameter packs (and tuples) to the
implementer's liking. These can then be used relatively normally by users, without tedious manual code.

### Implementation

Currently, there is only one implemented calling convention in Meta, although this will not be the case for long.
This calling convention is dubbed "optcall", as it is generated by the Microsoft Visual C++ compiler for tightly
optimized internal functions in 32-bit Intel x86 executables. 

### Optcall

Optcall follows a format similar to the standard 64-bit calling convention used on Microsoft Windows:
| Parameter type | 1 | 2 | 3 | 4 | 5+ |
| --- | --- | --- | --- | --- | --- |
| Floating point | xmm0 | xmm1 | xmm2 | xmm3 | stack |
| Integers, pointers | ecx | edx | stack | stack | stack |

Caller cleans the stack.

This is not replicable normally, but using some manipulation of parameter packs, we can actually transform
a call to an optcall function to a vectorcall function, with the exception of stack cleaning. This must
be implemented with inline assembly, but it is more minimal than manual passing of parameters in assembly.

While this readme will not go into detail about how specifically this is implemented (as C++ metaprogramming
is absolutely horrible to look at and work with), effectively, the class that implements optcall uses a 
sequence of indices in order (generated by a filter) to grab variables at certain offsets of the parameter
pack given, in order to restructure the call to place it correctly into a vectorcall wrapper. Another "function"
uses the sequence of indices in order to calculate the stack fix generated from the vectorcall wrapper, and undoes
it with a single line of inline assembly.
